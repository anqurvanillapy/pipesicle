<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="static/codehilite.css">
  <link rel="stylesheet" type="text/css" href="static/style.css">

  <title>Postocol</title>
</head>
<body>

<header>
<h1>Postocol</h1>
</header>

<hr>

<main>
<article>
<p><em>Fork me on <a href="https://github.com/anqurvanillapy/postocol">GitHub</a>!</em></p>
<p><strong>Posting Protocol</strong>, an opinionated abstract class for creating homemade static
site generator (SSG).</p>
<h2>Ad Hoc Workflow, But Extensive</h2>
<p>A simplified workflow of a single-page generator can mainly be like this:</p>
<div class="codehilite"><pre><span></span>                  load_templates()     publish()
                        |                  |
                        v                  v
(text.md) --+------- template ---+--&gt; (index.html)
            |                    |
            +-- post ---&gt; page --+
                 ^          ^
                 |          |
          load_posts()   render()
</pre></div>
<p>Load the <code>text.md</code> and render it using <code>python-markdown</code> and <code>BeautifulSoup4</code>.
In the meantime load the templates by <code>jinja2.Environment</code> and its
<code>FileSystemLoader</code>. Note that <code>render()</code> method is abstract and should be
implemented, where you could specify the manipulation of the preliminarily
rendered posts, e.g.</p>
<ul>
<li>creating your own table of contents,</li>
<li>separating the Markdown text into different sections for creating a slideshow
presentation,</li>
<li>collecting the posts' <em>tags</em>, <em>categories</em>, etc., generating a list for them.</li>
</ul>
<p>By doing these above, you've extended your homemade SSG into a <em>wiki</em>-like tool,
and a <em>blog</em> has a similar workflow as well.</p>
<div class="codehilite"><pre><span></span>(foo.md) --+
(bar.md) --+  clean(site/)  load_templates()  publish()  send_static()
           |         |            |              |             |
           v         v            v              v             v
       (content/) ---+----- templates ---+--&gt; (site/) --+-&gt; (site/static/)
                     |                   |              +-- (index.html)
                     +-- posts -&gt; pages -+              +-- (states.html)
                          ^         ^                   +-- (properties.html)
                          |         |                   +-- (foo.html)
                   load_posts()  render()               +-- (bar.html)
</pre></div>
<p>In this new one, you might need to clean the legacy generated pages ahead of
your publishing, and in the end of the control flow, send the static assets to
your <code>site/</code> folder, e.g. stylesheets, scripts, images.</p>
<h2>All You Need Is Implementing One Abstract Method</h2>
<p>The method is <code>render()</code>, in the workflow graphs above.</p>
<p>This project site was initially generated by this following snippet, which looks
<strong>weird</strong> but would be concise if you've gone through Postocol's philosophy.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">postocol</span> <span class="kn">import</span> <span class="n">Postocol</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">basename</span><span class="p">,</span> <span class="n">splitext</span>


<span class="k">class</span> <span class="nc">SSG</span><span class="p">(</span><span class="n">Postocol</span><span class="p">):</span>
    <span class="n">ifpath</span> <span class="o">=</span> <span class="s1">'preface.md'</span>
    <span class="n">ofpath</span> <span class="o">=</span> <span class="s1">'index.html'</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_templates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">posts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_posts</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">publish</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pages</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posts</span><span class="p">):</span>
        <span class="n">pages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chfn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">'{}.html'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">posts</span><span class="p">:</span>
            <span class="n">pages</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">'content'</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s1">'meta'</span><span class="p">:</span> <span class="n">m</span><span class="p">,</span> <span class="s1">'fname'</span><span class="p">:</span> <span class="n">chfn</span><span class="p">(</span><span class="n">f</span><span class="p">)})</span>

        <span class="k">return</span> <span class="n">pages</span>
</pre></div>
<h2>Check Out The Repo For More Details</h2>
<p>The repo is hosted on <a href="https://github.com/anqurvanillapy/postocol">GitHub</a>,
where there are a full manual on the <code>README.md</code> and an example of creating a
well-featured prototyped <strong>wiki generator</strong>.</p>
<div class="codehilite"><pre><span></span>$ git clone git@github.com:anqurvanillapy/postocol.git
$ <span class="nb">cd</span> postocol
$ python3 setup.py install
</pre></div>
<p>Anyway, feel free to create your issues, fork and pull your requests.</p>
<h2>License</h2>
<p>MIT</p>
</article>
</main>

<hr>

<footer>
<p>
Created by
<a href="https://github.com/anqurvanillapy/">AnqurVanillapy</a>.
Published by
<a href="https://github.com/anqurvanillapy/postocol">Postocol</a>,
indeed.
</p>
</footer>

</body>
</html>